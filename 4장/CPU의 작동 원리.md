# CPU의 작동 원리

## ALU와 제어장치

1. ALU와 제어장치
    - ALU : `계산하는 장치`
    - 제어장치 : 제어 신호를 발생시키고 명령어를 해석하는 장치

2. ALU
   - 계산을 하기 위해서는 `피연산자`와 `수행할 연산`이 필요하다.
   - 플래그 : 연산 결과에 대한 부가 정보 (ALU -> 플래그 레지스터)
      - ✔ `양수`와 `음수`를 구분한다.
      - ✔ 연산 결과가 너무 큰 경우에는 `오버플로우` 가 발생한다고 표현한다.

3. 제어장치
   - 클럭 신호 : 컴퓨터의 모든 부품을 일사분란하게 움직일 수 있게 하는 시간 단위

--------------------------------------------------------------------------------------------
## 레지스터

1. 레지스터
    - CPU 내부의 작은 임시저장장치
    - 프로그램 속 명령어와 데이터는 실행 전 후로 `레지스터에 저장`된다.
    - CPU 내부에는 다양한 레지스터가 있고 각기 다른 `역할`을 가진다.

2. 레지스터의 종류
    1. 프로그램 카운터 : 메모리에서 가져올 명령어의 주소(메모리에서 `읽어들일 명령어의 주소`)
       - **💡 순차적인 실행 흐름이 끊기는 경우**
          - 특정 메모리 주소로 실행 흐름을 이동하는 명령어 실행 시 ( ex. JUMP)
          - 인터럽트 발생 시에 
    2. 명령어 레지스터 : 해석할 명령어 (방금 메모리에서 읽어들인 명령어)
    3. 메모리 주소 레지스터 : 메모리의 주소(CPU가 읽어 들이고자 하는 주소를 `주소 버스`로 보낼 때 거치는 레지스터)
    4. 메모리 버퍼 레지스터 : 메모리와 주고 받을 값(데이터와 명령어 : CPU가 정보를 `데이터 버스`로 주고 받을 때 거치는 레지스터)
    5. 플래그 레지스터 : 연산 결과 또는 CPU 상태에 대한 `부가`적인 정보
    6. 범용 레지스터 : 다양하고 `일반적`인 상황에서 자유롭게 사용
    7. 스택 포인터 : 스택의 `꼭대기`를 가리키는 레지스터(**스택이 어디까지 차 있는지에 대한 표시**)
       - 스택 주소 지정 방식 : 스택과 스택 포인터를 이용한 주소 지정 방식
    8. 베이스 레지스터 : 기준 주소 저장
       - 변위 주소 지정방식 : 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 `더해서` 유효 주소를 얻는 방식
       - **💡 특정 레지스터의 종류** 
             - 상대 주소 지정 방식 : 오퍼랜드 필드와 값(변위)과 `프로그램 카운터`의 값을 더해서 유효 주소 얻기
             - 베이스 레지스터 주소 지정 방식 : 오퍼랜드 필드와 값(변위)과 `베이스 레지스터(기준 주소)`의 값을 더해서 유효 주소 얻기

--------------------------------------------------------------------------------------------
## 명령어 사이클과 인터럽터

1. 명령어 사이클
    - 프로그램 속 명령어들을 `일정한 주기`가 반복되며 실행된다.
    - 해당 주기를 `명령어 사이클`이라고 부른다.
2. 명령어 사이클의 종류
    1. 인출 사이클 : 가장 먼저 `CPU`로 갖고 와야한다.
    2. 실행 사이클 : 갖고 온 명령어를 실행한다.
       * `인출-실행` 의 과정이 반복된다. 
       * 메모리 접근이 더 필요한 경우에는 `간접 사이클` 을 거쳐 실행된다.
       * 인터럽트가 발생한 경우에는 `인터럽트 사이클` 을 거쳐 실행된다.

3. 인터럽트(interrupt)
   - 방해하다, 중단시키다 라는 의미를 가진다.
   - `CPU`가 꼭 주목하거나 얼른 처리해야할 다른 작업이 생겼을 때 발생한다.

4. 인터럽트의 종류
    1. 동기(`예외`) 인터럽트
       - CPU가 `예기치 못한 상황`을 접했을 때 발생한다.
       - 폴트, 트랩, 중단, 소프트웨어 인터럽트 등이 존재한다.
    2. 비동기(`하드웨어`) 인터럽트
       - 주로 `입출력장치`에 의해 발생한다.
       - ex) 알림(세탁기 완료, 키보드, 마우스 클릭 등)과 같은 역할
       - 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해서 사용한
       - 입출력 장치는 CPU에 비해 `느리다` -> 입출력 작업 동안 CPU는 다른 작업을 진행할 수 있다.
    2-1. 하드웨어 인터럽트 처리 순서
          1. 입출력 장치는 CPU에 `인터럽트 요청 신호`를 보낸다.
          2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 `인터럽트 여부를 확인`한다. 
          3. CPU는 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는 지 확인한다.
          4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다. - `스택 영역`에 백업한다.
          5. CPU는 `인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행한다.
          6. 인터럽트 서비스 루틴 실행이 끝나면 `4`에서 백업해둔 작업을 복구하여 실행을 재개한다.
    2-2. 하드웨어 인터럽트 요청 키워드
          1. 인터럽트 요청 신호 : CPU의 작업을 방해하는 인터럽트에 대한 요청
          2. 인터럽트 플래그 : 현재 인터럽트를 요청을 받아들일 지 무시할 지 결정하는 비트(`모든 인터럽트를 인터럽트 플래그로 막을 수 있지는 않다` : NMI)
          3. 인터럽트 벡터 : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
          4. 인터럽트 서비스 루틴 
              - CPU가 인터럽트를 받아들이기로 했다면 `인터럽트 서비스 루틴`이 실행된다.
              - 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하기 위한 `프로그램`(ex. 키보드가 인터럽트 요청 요청을 보내면 이렇게 행동하세요)
              - 프로그램이 때문에 `메모리`에 저장한다
              - 인터럽트의 주체에 따라 각기 다른 인터럽트 서비스 루틴을 가지고 있다.
    3. `CPU가 인터럽트를 처리한다`
        - `인터럽트 서비스` 루틴을 실행하고 본래 수행하던 작업으로 `되돌아온다`
        - 그리고 인터런트 시작 주소는 인터럽트 벡터를 통해서 알 수 있다.

--------------------------------------------------------------------------------------------
