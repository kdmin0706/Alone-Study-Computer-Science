# 보조기억장치

## 다양한 보조기억장치

### 1. 하드디스크
 - `자기적인 방식`으로 데이터 저장
 - 구성요소
   1. 스핀들
   2. 플래터 : 일반적으로 플래터의 `양면`을 모두 사용한다 (RPM(Revolution Per Minute) : 분당 회전수)
   3. 헤드 : 일반적으로 모든 헤드가 `디스크 암`에 부착되어 함께 이동한다.
   4. 디스크 암
 - 데이터 저장 단위
   <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/a7d1a0fd-94e8-4da6-82dc-abfbd7133321"  width="500" height="300"/>
   - 기본적으로 `트랙(track)`과 `섹터(sector)` 단위로 데이터를 저장한다.
   - 섹터의 크기 : 512 바이트 ~ 4096 바이트
   - 블록(block) : 하나 이상의 섹터를 `묶어서` 표현한다.
     <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/5d779884-015e-4484-8d14-f6e0467318d5"  width="500" height="300"/>
   - 실린더(cylinder)
     - 여러 겹의 플래터 상에서 `같은 트랙이 위치한 곳`을 모아 연결한 논리적 단위
     - 연속된 정보는 `한 실린더`에 기록된다.

### 2. 하드 디스크 - 데이터 접근 과정
 - 하드 디스크가 저장된 데이터에 접근하는 시간
   1. **탐색 시간(seek time)** : 접근하려는 데이터가 저장된 트랙까지 헤드르르 이동시키는 시간
      <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/c3f3f25e-4cf7-4d0a-b3c5-4c250f99ca39"  width="500" height="300"/>
   2. **회전 지연(rotational latency)** : 헤드가 있는 곳으로 플래터를 회전시키는 시간
      <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/8b8cb1e8-80dc-4c1b-9c6f-735d9e1eba24"  width="500" height="300"/>
   3. **전송 시간(transfer time)** : 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간
      <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/4f7e876b-970d-458c-92c4-49fc74384b96"  width="500" height="300"/>
   
### 3. 플래시 메모리
 - 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치
 - 범용성이 넓기에 `보조기억장치에만 속한다`고 보기는 어렵다.
 
### 4. 플래시 메모리의 종류
 - **NAND 플래시 메모리**
 - NOR 플래시 메모리

### 5. 플래시 메모리의 구성요소
 - 셀(cell) 
   1. 플래시 메모리에서 데이터를 저장하는 가장 작은 단위
   2. 셀이 모여서 `MB`,`GB`,`TB` 저장 장치가 된다.
   3. 저장할 수 있는 플래시 메모리 종류
      <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/d3ac1359-55fb-4185-af59-7749f97540d9"  width="500" height="300"/>
      - SLC : 1비트를 저장할 수 있는 플래시 메모리
        1. 하나의 셀로 2개의 정보를 표현
        2. 비트의 빠른 입출력
        3. 긴 **수명** -> 플래시 메모리(USB, SSD, SD 카드), 하드 디스크에는 수명이 존재한다.
        4. 용량 대비 가격이 비싸다
      - MLC : 2비트를 저장할 수 있는 플래시 메모리
        1. 하나의 셀로 4개의 정보를 표현(`대용량화 유리`)
        2. SLC보다 느린 입출력
        3. SLC보다 짧은 수명
        4. SLC보다 저렴하다
        5. 시중에서 많이 사용한다(MLC, TLC, QLC)
      - TLC : 3비트를 저장할 수 있는 플래시 메모리
        1. 하나의 셀로 8개의 정보를 표현(`대용량화 유리`)
        2. MLC보다 느린 입출력
        3. MLC보다 짧은 수명
        4. MLC보다 저렴하다
        5. 시중에서 많이 사용한다(MLC, TLC, QLC)
      - QLC : 4비트를 저장할 수 있는 플래시 메모리
### 6. 플래시 메모리의 저장 단위
  - 저장 단위
    1. 셀이 모이면 페이지(page)
    2. 페이지가 모이면 블록(block)
    3. 블록이 모이면 플레인(plane)
    4. 플레인 모이면 다이(die)
    5. 읽기/쓰기 단위와 삭제 단위는 다르다
  - 읽기와 쓰기는 `페이지` 단위로 이루어진다.
  - 삭제는 (페이지보다 큰) `블록` 단위로 이루어진다.
  - 페이지의 상태
    1. `Free` 상태 : 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태
    2. `valid` 상태 : 이미 유효한 데이터를 저장하고 있는 상태
    3. `invalid` 상태 : 유효하지 않은 데이터(쓰레기값)를 저장하고 있는 상태
<br><br>

  - **가비지 컬렉션**
  <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/bd26c19f-1476-4136-89bd-cedddadf8cef"  width="500" height="300"/>
    1. 유효한 페이지들만 `새로운 블록`으로 복사
    2. 기존 블록을 삭제

--------------------------------------------------------------------------------------------
## RAID의 정의와 종류

### 1. RAID(Redundant Array of Independent Disks)
 - `하드 디스크`와 `SSD`로 사용하는 기술
 - 데이터의 `안전성` 혹은 `높은 성능`을 위해 여러 물리적 보조기억장치를 마치 하나의 논리적 보조기억장치처럼 사용하는 기술
 - ex) 1TB 장치 5개가 아니라 5TB를 하나의 장치로 사용하고 싶다!
   <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/a59cfa86-f129-4e7d-8f11-2b264e3b8046"  width="500" height="300"/>

### 2. RAID의 종류
  1. RAID 레벨
     - RAID를 구성하는 기술
     - ex) RAID 0, RAID 1, RAID 2, RAID 3 ... 

### 3. RAID 0
  - 특징
    1. 장점 : 입출력 속도의 향상
    2. 단점 : 저장된 정보가 안전하지 않다.
  - 데이터를 단순히 나누어 저장하는 구성 방식
  - 각 하드 디스크는 번갈아 가며 데이터를 저장한다.
  - 저장되는 데이터가 하드 디스크 개수만큼 나뉘어 저장
   <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/ac7451a5-101c-4037-839e-4f3106a0142d"  width="500" height="300"/>
  - 스트라입(stripe) : 마치 줄무늬처럼 분산되어 저장된 데이터
  - 스트라이핑(striping) : 분산하여 저장하는 것

### 4. RAID 1
  - 특징
     1. 미러링(mirroring) : 복사본을 만드는 방식
         - 데이터를 쓸 때 `원본`과 `복사본`에 사용된다(`느린 쓰기 속도`)
        <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/b2b6d0a9-4504-4201-a6c0-d170055ee18f"  width="500" height="300"/>
     2. 단점 : 하드 디스크의 개수가 한정되어 있을 경우 사용 가능한 용량이 적어진다.
         - 복사본이 만들어지는 용량만큼 사용 불가 -> 많은 하드 디스크가 필요하다 -> 비용 증가

### 5. RAID 4
  - 특징
    1. 오류를 검출하고 복구하기 위한 정보(`페리티 비트`)를 저장(RAID 1처럼 완전한 복사본을 만든다)
      <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/283bffe0-cb06-4d81-88d5-2459eea77284"  width="500" height="300"/>
    2. 페리티를 저장한 장치를 이용해 다른 장치들의 오류를 검출하고, 오류가 있다면 복구
    3. 단점 : 패리티 디스크의 병목현상 발생
       - 데이터를 새롭게 쓸 때마다 반드시 패리티 디스크에 저장해야하기 때문이다.

    
### 6. RAID 5
  - 특징
    1. 패리티 정보를 `분산`하여 저장하는 방식
       <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/fd5f6b59-70b7-456d-ab36-9621511eda0d"  width="500" height="300"/>

### 7. RAID 6
  - 특징
    1. 두 종류의 패리티(`오류를 검출`하고 `복구`할 수 있는 수단)
    2. RAID 5보다는 안전하다, 쓰기는 RAID 5보다 느리다. 
        <img src="https://github.com/kdmin0706/Algorithm/assets/124044861/a2a55b82-5cae-41ab-a060-5b0730d64257"  width="500" height="300"/>


--------------------------------------------------------------------------------------------